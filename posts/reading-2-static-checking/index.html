<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.77710d9cc4453f184694.css">@import url(https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@500&display=swap);@font-face{font-family:JetBrains Mono;src:url(/static/fonts/JetBrains-mono.woff)}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:JetBrains Mono,Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}@font-face{font-family:JetBrains Mono;src:url(/static/fonts/JetBrains-mono.woff) format("woff")}@font-face{font-family:JetBrains Mono;font-weight:700;src:url(/static/fonts/JetBrains-mono-bold.woff) format("woff")}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font:112.5%/1.45em georgia,serif,sans-serif;box-sizing:border-box}body{margin:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:rgba(0,0,0,.8);font-family:JetBrains Mono,Noto Sans JP,sans-serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}article,aside,details,figcaption,figure,footer,header,main{background-color:"#111";margin:auto;display:flex;flex-direction:column;align-items:center}menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help;text-decoration:none}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{padding:0;margin:0 0 1.45rem;color:inherit;font-family:JetBrains Mono,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:2.25rem;line-height:1.1}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none;max-width:100%;padding:0;margin:0 0 1.45rem}svg:not(:root){overflow:hidden}kbd,pre,samp{font-family:JetBrains Mono,monospace;font-size:1em}figure{padding:0;margin:0 0 1.45rem}hr{box-sizing:content-box;overflow:visible;padding:0;margin:0 0 calc(1.45rem - 1px);background:rgba(0,0,0,.2);border:none;height:1px}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;padding:0;margin:0 0 1.45rem}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}*,:after,:before{box-sizing:inherit}h2{font-size:1.62671rem}h2,h3{padding:0;margin:0 0 1.45rem;color:inherit;font-family:JetBrains Mono,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h3{font-size:1.38316rem}h4{font-size:1rem}h4,h5{padding:0;margin:0 0 1.45rem;color:inherit;font-family:JetBrains Mono,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h5{font-size:.85028rem}h6{color:inherit;font-family:JetBrains Mono,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;font-size:.78405rem;line-height:1.1}h6,hgroup{padding:0;margin:0 0 1.45rem}ol,ul{padding:0;margin:0 0 1.45rem 1.45rem;list-style-position:outside;list-style-image:none}dd,dl,p{padding:0}dd,dl,p,pre{margin:0 0 1.45rem}pre{font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{padding:0;margin:0 0 1.45rem;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%;overflow-x:scroll}blockquote{padding:0;margin:0 1.45rem 1.45rem}address,form,iframe,noscript{padding:0;margin:0 0 1.45rem}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:JetBrains Mono,SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}</style><meta name="generator" content="Gatsby 2.24.63"/><title data-react-helmet="true"></title><meta data-react-helmet="true" charSet="utf-8"/><link rel="icon" href="/favicon-32x32.png?v=4a9773549091c227cd2eb82ccd9c5e3a" type="image/png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link as="script" rel="preload" href="/webpack-runtime-da31a781e9bbfb08e6c9.js"/><link as="script" rel="preload" href="/framework-9d194516e0be0e5de3bc.js"/><link as="script" rel="preload" href="/app-6630ef88235aa306c41d.js"/><link as="script" rel="preload" href="/styles-89fd2ae28bdf06750a71.js"/><link as="script" rel="preload" href="/93a75765fdacf44a41c62e8a54345fad25392349-416bc51ce4ed34ec148a.js"/><link as="script" rel="preload" href="/component---src-templates-post-template-js-fabb72bb863d7da60910.js"/><link as="fetch" rel="preload" href="/page-data/posts/reading-2-static-checking/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/3649515864.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="application"></div><header style="background:#6B7089;margin-bottom:1.45rem;padding:1rem;max-width:100vw"><h1 style="margin:1rem"><a style="color:white;text-decoration:none" href="/">Yim Devlog</a></h1><div class="header-menu" style="display:flex;flex-direction:row"><h3 style="margin:auto;margin-left:2rem;padding:auto"><a style="color:white;text-decoration:none" href="/about">About</a></h3><h3 style="margin:auto;margin-left:2rem;padding:auto"><a style="color:white;text-decoration:none" href="/posts">Posts</a></h3></div></header><div style="margin:0 auto;max-width:960px;padding:0 1.0875rem 1.45rem"><main><div class="blog-post-container"><div class="blog-post" style="max-width:90vw"><h1>MIT 6.001 Reading 1: Static Checking</h1><h2>September 19, 2020</h2><div class="blog-post-content"><h1>읽기 1: 정적 검사(Static Checking)</h1>
<h3>오늘 수업의 주제들</h3>
<p>오늘 수업에는 두 가지 토픽이 있습니다:</p>
<ul>
<li>정적 타이핑(static typing)</li>
<li>좋은 소프트웨어의 세가지 큰 요소</li>
</ul>
<h2>우박 나열식 (Hailstone Sequence)</h2>
<p>예시를 위해, 우리는 우박 나열식에 대해 알아볼 것입니다. 우박 나열식이란 다음과 같은 연속된(시퀀스) 숫자들입니다. 숫자 n으로 시작하여, n이 짝수일 경우 n/2이, 홀수일 경우 3n+1이 그 다음에 옵니다. 나열식은 숫자 1에 도달하면 끝납니다. 아래 예시를 들어보겠습니다.</p>
<blockquote>
<p>2, 1
3, 10, 5, 16, 8, 4, 2, 1
4, 2, 1
n<sup>2</sup>, 2<sup>n-1</sup>, ... , 4, 2, 1</p>
<p>5, 16, 8, 4, 2, 1</p>
<p>7, 22, 11, 34, 17, 52, 26, 13, 40, ... ? (이건 언제 멈추죠?)</p>
</blockquote>
<p>홀수일 경우의 규칙 때문에, 나열식은 1로 수렴하기 전까지 커지기도 작아지기도 합니다. 우박들(숫자들)은 결국엔 바닥으로(숫자1로) 떨어질 것이라고 추측 할 수 있지만 -- 우박 나열식은 모든 n으로 시작하는 경우엔 1에 도달합니다 -- 여전히 완전히 풀리진 않았습니다. 왜 '우박 나열식'이라는 이름을 지었을까요? 우박들은 구름안에서 위 아래로 튀다가 충분히 무거워지면 땅으로 떨어지기 때문입니다.</p>
<h2>우박들을 계산하기</h2>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token comment">// Java</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		n <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<div class="gatsby-highlight" data-language="python"><pre class="language-python"><code class="language-python"><span class="token comment"># python</span>
n <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">while</span> n <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> n
    <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span>
<span class="token keyword">print</span> n</code></pre></div>
<p>몇몇 내용들은 여기 기록해둘 필요가 있겠습니다:</p>
<ul>
<li>자바와 파이썬의 기본적인 언어적 표현들(semantics of expressions)과 구문(statements)들은 매우 비슷합니다: 예를들어 <code class="language-text">while</code> 과 <code class="language-text">if</code>는 똑같은 의미를 가집니다.</li>
<li>자바는 구문의 끝에 세미콜론을 붙여줘야 합니다. 추가적인 글자를 입력해야 하는 것은 귀찮을 수 있지만 대신, 더 자유롭게 코드를 정리할 수 있습니다. - 예를 들어 가독성을 위해 구문들을 여러 줄로 나눌 수 있습니다.</li>
<li>자바는 <code class="language-text">if</code>와<code class="language-text">while</code>의 조건문에 괄호를 써주어야합니다.</li>
<li>자바는 한 블록을 표현 할 때 인덴트(indentation) 대신 {}로 감싸줘야 합니다. 자바 문법상 인덴테이션은 무시되지만, 꼭 인덴트를 해야합니다. 프로그래밍은 커뮤니케이션의 일종입니다. 당신은 컴파일러뿐만 아니라 사람과도 커뮤니케이션 하는 것이고 사람에겐 인덴테이션이 필요합니다.</li>
</ul>
<h2>타입(Types)</h2>
<p>위의 코드에서 자바와 파이썬의 가장 중요한 차이첨은 변수 n의 선언에 있습니다. 특히 타입 <code class="language-text">int</code>를 지정하는 부분이죠.</p>
<p><strong>타입</strong>은 값들과 그 값들에 수행 가능한 연산들의 모음입니다.</p>
<p>자바는 몇몇 <strong>원시 타입(primitive types)들</strong>을 가지고 있습니다:</p>
<ul>
<li><code class="language-text">int</code> (5나 -200과 같은 정수들, ±2<sup>31</sup>혹은 대략 ± 20억의 범위)</li>
<li><code class="language-text">long</code> (조금더 넓은 범위의 정수들, ±2<sup>63</sup>의 범위)</li>
<li><code class="language-text">boolean</code> (참과 거짓)</li>
<li><code class="language-text">double</code> (부동소수점 숫자들, 실수의 일부를 나타냅니다.)</li>
<li><code class="language-text">char</code> (<code class="language-text">&#39;A&#39;</code>나<code class="language-text">&#39;$&#39;</code>와 같은 문자들)</li>
</ul>
<p>자바는 또한 <strong>객체 타입(object types)들</strong> 예를 들어:</p>
<ul>
<li><code class="language-text">String</code>은 파이썬의 <code class="language-text">string</code>과 같이 연속된 문자들을 나타냅니다.</li>
<li><code class="language-text">BingInteger</code>는 파이썬의 <code class="language-text">integer</code>처럼 임의의 범위의 정수를 나타냅니다.</li>
</ul>
<p>자바는 관례(convention)상, 원시 타입들은 소문자로, 객체 타입은 대문자로 시작합니다.</p>
<p><strong><em>연산(Operations)들</em></strong>은 입력을 받아 출력을 만드는(때때로는 그 자신의 값을 변경하기도 합니다.) 함수들(functions)입니다. 연산들의 문법은 다양하지만, 어떤 식으로 쓰여져 있건 그들은 함수들 입니다. 파이썬과 자바에는 다음과 같이 연산을 위한 세 가지 다른 문법들이 있습니다:</p>
<ul>
<li><strong><em>infix, prefix, 혹은 postfix 로.</em></strong> 예를 들어 <code class="language-text">a + b</code>는 연산 <code class="language-text">+ : int × int → int</code>를 나타냅니다.</li>
<li><strong><em>객체의 메쏘드(method)로.</em></strong> 예를 들어 <code class="language-text">bingint1.add(bigint2)</code>는 연산 <code class="language-text">add : BigInteger × BigInteger → BigInteger</code>를 호출(call)합니다.</li>
<li><strong><em>함수로.</em></strong> 예를 들어 <code class="language-text">Math.sin(theta)</code>는 연산 <code class="language-text">sin : double → double</code>를 호출합니다. 여기서 <code class="language-text">Math</code>는 객체가 아닙니다. <code class="language-text">sin</code>함수를 포함하는 클래스(class)이죠.</li>
</ul>
<p>자바의 <code class="language-text">str.length()</code>와 파이썬의 <code class="language-text">len(str)</code>를 비교해보세요. 이 둘은 같은 연산을 실행 -- string을 받아 그 길이를 반환하는 함수 -- 하지만 단지 문법이 다를 뿐이죠.</p>
<p>몇몇 연산들은 같은 개념의 연산을 다른 타입에 사용하도록 <strong>오버로드(overloaded)</strong>되어 있습니다. 산술 연산 <code class="language-text">+</code>,<code class="language-text">-</code>, <code class="language-text">*</code>,<code class="language-text">/</code>는 자바의 숫자원시타입들(numeric primitive types)을 위해 오버로드 되어있습니다. 메쏘드들 또한 오버로드 될 수 있습니다. 대부부의 프로그래밍 언어들은 어느 정도의 오버로딩을 가지고 있습니다.</p>
<h2>정적 타이핑(Static Typing)</h2>
<p>지바는 <strong>정적-타입 언어(statically-typed language)</strong>입니다. 모든 변수들의 타입을 컴파일시(프로그램이 실행되기 전)에 알 수 있기 때문에, 컴파일러는 모든 표현식의 타입을 미리 파악 할 수 있습니다. 만약 <code class="language-text">a</code>와 <code class="language-text">b</code>가 <code class="language-text">int</code>로 선언되었다면, 컴파일러는 <code class="language-text">a + b</code>또한 <code class="language-text">int</code>타입이라고 판단합니다. 이클립스(Eclipse)환경은 당신이 코드를 작성하는 중에 이것을 판단하고, 따라서 당신이 타이핑하는 동시에 이미 많은 에러들을 찾아낼 수 있습니다.</p>
<p>파이썬과 같은 <code class="language-text">동적-타입 언어들(dynamically-typed languages)</code>은 이러한 검사를 런타임(프로그램이 실행되는 도중)까지 미뤄두게 됩니다.</p>
<p>정적 타이핑은 버그를 컴파일시에 검사하는 <strong>정적-검사(static checking)</strong>의 한 유형입니다. 버그는 프로그래밍의 골칫거리입니다. 이 코스의 생각거리의 대부분은 이러한 버그들을 제거하는 것이고 정적검사가 그 중 첫번째입니다. 정적 타이핑은 수 많은 버그들이 프로그램을 감염시키는 것을 막아줍니다: 정확히는, 타입에 맞지 않는 연산에 대한 버그들을 막아주는 것입니다. 만약 아래와 같이 두 문자열을 곱하려고 하는 잘못된 코드를 작성한다면</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token string">"5"</span> <span class="token operator">*</span> <span class="token string">"6"</span></code></pre></div>
<p>정적 타이핑은 프로그램이 실행되기 전, 프로그램을 작성하는 중에 이러한 오류를 막아줄 것입니다.</p>
<h2>정적 검사, 동적 검사, 검사 없음(Static Checking, Dynamic Checking, No Checking)</h2>
<p>프로그래밍 언어가 제공하는 세 종류의 자동 검사에 대해 생각해봅시다.</p>
<ul>
<li><strong>정적 검사</strong> : 프로그램이 실행되기도 전에 자동으로 버그가 발견됨</li>
<li><strong>동적 검사</strong> : 프로그램이 실행되는 도중 자동적으로 버그가 발견됨</li>
<li><strong>검사 없음</strong> : 언어가 오류를 찾는데 도움을 주지 않습니다. 스스로 찾아내거나, 혹은 잘못된 것을 모른채 넘어가게 됩니다.</li>
</ul>
<p>말할 필요도 없이, 정적으로 버그를 찾아내는 것이 동적으로 찾아내는 것보다 좋고, 동적으로 찾아내는 것이 찾아내지 못하는 것보다 낫습니다.</p>
<p>다음은 각각의 검사에서 찾아낼 수 있는 버그들의 예시입니다.</p>
<p><strong>정적 검사</strong>:</p>
<ul>
<li>문법 오류: 잘못된 단어나 여분의 구두점(punctuation). 파이썬과 같은 동적-타입 언어조차 이러한 유형의 정적 검사를 수행합니다. 만약 파이썬 프로그램에 들여쓰기 문제가 있는 경우, 프로그램이 시작되기 전에 발견 할 수 있을 것입니다.</li>
<li><code class="language-text">Math.sine(2)</code>와 같은 잘못된 이름들 (올바른 이름은 <code class="language-text">sin</code>입니다.)</li>
<li><code class="language-text">Math.sin(30, 20)</code>과 같은 잘못된 인수의 개수</li>
<li><code class="language-text">Math.sin(&quot;30&quot;)</code>과 같은 잘못된 인수의 타입</li>
<li><code class="language-text">int</code>로 정의된 함수에 적힌 <code class="language-text">return &quot;30&quot;</code>과 같은 잘못된 반환 타입들</li>
</ul>
<p><strong>동적 검사</strong>:</p>
<ul>
<li>잘못된 인수의 값. 예를 들어, 정수 표현 <code class="language-text">x/y</code>는 <code class="language-text">y</code>의 값이 0일때만 오류가 됩니다, 다른 경우엔 잘 동작합니다. 따라서 이 표현식에서 '0으로 나눔(divide-by-zero)'는 정적 오료가 아닌 동적 오류입니다.</li>
<li>표현 불가능한 반환 값. 특정 반환값이 그 타입으로 표현 할 수 없는 것일 때</li>
<li>범위를 벗어난 인덱스(out-of-range indexes), 예를 들어 문자열의 음수 인덱스나, 너무 큰 인덱스</li>
<li><code class="language-text">null</code>객체에 대한 메쏘드 호출(<code class="language-text">null</code>은 파이썬의 <code class="language-text">None</code>과 유사한 객체입니다.)</li>
</ul>
<p>정적 검사는 변수가 가진 값과 무관한, 그 타입에 관한 오류에 관한 것이 많습니다. 타입은 값들의 집합이며, 정적 타이핑은 특정 변수가 특정한 집합내의 값을 가질것을 보장해줍니다. 하지만 실제로 어떤 값을 가지게 될지는 런타임 전에는 알 수 없습니다. 따라서 특정한 값에 의해서 오류가 발생한다면 (divide-by-zero와 같은) 컴파일러는 정적 오류로서 그것을 발견 하지 못합니다.</p>
<p>동적 검사는 그와 반대로 특정 값에 관련된 오류를 찾아내는 경우가 많습니다.</p>
<h2>놀람주의: 원시 타입은 진짜 '숫자'는 아닙니다. (Surprise: Primitive Types Are Not True Numbers)</h2>
<p>많은 프로그래밍 언어, 그리고 자바의 한가지 함정은 원시 숫자 타입이 실제 정수나 실수와 같이 행동하지 않는 경우가 있다는 것입니다. 그 결과, 동적으로 검사되야할 몇몇 오류들이 아예 검사되지 않는 경우가 있습니다.</p>
<p>여기 그 함정들의 예시를 봅시다:</p>
<ul>
<li><strong>정수 나눗셈(Integer division)</strong>: <code class="language-text">5/2</code>는 분수를 반환하지않고, 잘린 정수를 반환합니다. 이것은 동적 검사에서 발견되길 바라는 오류(왜냐하면 난눗셈 연산은 정수타입으로 표현할 수 없는 반환값이기 때문에)이지만 자주 틀린채로 넘어가는 오류입니다.</li>
<li><strong>정수 오버플로우(Integer overflow)</strong>: <code class="language-text">int</code>와 <code class="language-text">long</code>타입은 최대/최소값이 정해진 유한한 정수의 집합입니다. 만약 그 범위를 벗어나는 너무 크거나 작은 반환값이 계산된다면 어떤 일이 벌어질까요? 계산 결과는 `조용히` <em>오버플로우</em> 되고 정상적인 범위내에 있는 <em>잘못된</em> 값은 반환 할 것입니다.</li>
<li><strong><code class="language-text">float</code>과 <code class="language-text">doubles</code>의 특별한 값들</strong>: <code class="language-text">float</code>과 <code class="language-text">double</code>타입은 실수가 아닌 몇몇 특별한 값들을 가집니다: <code class="language-text">NaN</code>("Not a Number"의 의미의 값), <code class="language-text">POSITIVE_INFINITY</code>(양의 무한)그리고 <code class="language-text">NEGATIVE_INFINITY</code>(음의 무한). 따라서 동적 오류를 예상하는 연산들(0으로 나눗셈을 하거나 음수의 제곱근을 구하는 등)이 대신 이런 특별한 값을 반환하게 됩니다. 그 반환값으로 계속 연산을 실행해버린다면, 최종적으로는 잘못된 결과가 나오게 될 것입니다.</li>
</ul>
<h2>배열 및 컬렉션(Arrays and Collections)</h2>
<p>우리의 우박 계산을 변형시켜 단순히 숫자를 나열하는 것이 아닌, 데이터 구조(data structure)에 저장하도록 해봅시다. 자바는 배열(arrays)과 리스트(Lists), 두 종류의 list-like 타입들을 사용할 수 있습니다.</p>
<p>배열은 타입 T에 대한 고정된 길이(fixed-length) 의 시퀀스입니다. 아래와 같이 배열변수를 선언하고 값을 할당 할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div>
<p>위의 <code class="language-text">int[]</code>배열 타입은 모든 가능한 배열 값을 포함하지만, 한번 생성되면 그 길이는 변경 할 수 없습니다. 배열 타입에 포함된 연산은:</p>
<ul>
<li>인덱싱(indexing): <code class="language-text">a[2]</code></li>
<li>할당(assignment): <code class="language-text">a[2]=0</code></li>
<li>길이(length): <code class="language-text">a.length</code>(<code class="language-text">String.length()</code>와는 다릅니다. <code class="language-text">a.length</code>는 메소드 호출이 아니므로 뒤에 괄호가 들어가지 않습니다.)</li>
</ul>
<p>같은 것들이 있습니다.</p>
<p>아래에 배열을 사용한 우박 코드가 있습니다. 배열을 구성(constructing)하는 것으로 시작해 인덱스 변수 <code class="language-text">i</code>를 이용해 단계별로 생성된 시퀀스 값을 저장합니다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &lt;==== DANGER WILL ROBINSON</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// very common shorthand for i=i+1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
i<span class="token operator">++</span><span class="token punctuation">;</span></code></pre></div>
<p>위와 같은 접근방식에는 무언가 잘못된 <strong>냄새</strong>가 납니다. 대체 이 마법의 숫자 `100`은 뭘까요? 만약 우리가 매~우 긴 우박 시퀀스를 만드는 숫자 n으로 연산을 시도한다면 무슨 일이 일어날까요? 길이 100의 배열에 들어가지 않을 것입니다. 버그가 발생해 버린 것이죠. 자바가 이러한 버그를 정적으로 찾아줄까요? 아니면 동적으로? 아니면 아예 찾지 못할까요? 참고로 이러한 유형의 버그 - 고정 길이의 배열을 오버플로우하는 - 들은 C 나 C++와 같이 배열 액세스를 런타임에 자동으로 검사해주지 않는 less-safe한 언어들의 많은 네트워크 보안 침해의 원인이 되었습니다. (인터넷 웜이 그 예시입니다.)</p>
<p>고정 길이의 배열을 사용하는 대신, <code class="language-text">List</code>타입을 사용해 봅시다. List는 타입 T에 대한 동적 길이(variable-length)의 시퀀스입니다. 아래와 같이 <code class="language-text">List</code>변수를 선언하고 값을 만들 수 있습니다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>그리고 다음과 같은 연산들을 가집니다:</p>
<ul>
<li>인덱싱(indexing): <code class="language-text">list.get(2)</code></li>
<li>할당(assignment): <code class="language-text">list.set(2, 0)</code></li>
<li>길이: <code class="language-text">list.size()</code></li>
</ul>
<p><code class="language-text">List</code>는 인터페이스(interface)라는 것을 기억합니다. <code class="language-text">List</code>인터페이스는 new를 이용해 구축(construct) 할 수 없는 대신 <code class="language-text">List</code>가 반드시 제공해야하는 연산들을 지정해둔 타입입니다. 이것에 관한 자세한 이야기는 추상 데이터 타입(abstract data type) 강의에서 하도록 합시다. <code class="language-text">ArrayList</code>는 (위의 <code class="language-text">List</code>인터페이스가 요구하는) 이러한 연산들을 제공하는 구체적인 구축(implement) 클래스 입니다. <code class="language-text">ArrayList</code>가 <code class="language-text">List</code>타입의 유일한 구축(implementation)은 아니지만 가장 널리 사용됩니다. <code class="language-text">LinkedList</code>라는 것도 있죠. 웹에서 "Java 8 API"를 검색하면 찾아볼 수 있는 자바 API 문서를 확인해 보세요. 그들은 당신의 친구입니다. ("API"란 "application programmer interface"의 약자입니다. 보통 라이브러리(library)와 유의어로 사용됩니다.)</p>
<p>또 우리가 <code class="language-text">List&lt;int&gt;</code> 대신 <code class="language-text">List&lt;Integer&gt;</code>를 사용했다는 점을 기억해두세요. 불행히도 우리는 <code class="language-text">int[]</code>와 직관적으로 비슷하게 <code class="language-text">List&lt;int&gt;</code>를 만들어 사용할 수 없습니다. 리스트는 원시타입이 아닌 오직 객체타입만 다루도록 되어있기 때문이죠. 자바에서 각각의 원시타입들(보통 소문자로 쓰여져있고 이름이 축약되어 있는, 예를 들어 <code class="language-text">int</code>와 같은)은 그에 해당하는 객체타입(대문자로 시작하며 풀네임으로 적힌, 예를 들어 <code class="language-text">Integer</code>와 같은)이 존재합니다. 자바에서 꺾인 괄호(&#x3C;>)에 타입을 인수로 전달 할 때는 이러한 객체 타입을 사용해야 합니다. 그러나 다른 경우에, 자바는 <code class="language-text">int</code>와 <code class="language-text">Integer</code>를 자동으로 변환 해주므로, 우리는 <code class="language-text">Integer i = 5</code>와 같은 코드를 타입 오류 없이 사용 할 수 있습니다.</p>
<p>아래에 리스트를 사용한 우박 코드를 살펴봅시다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        n <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>리스트는 숫자들을 추가 할 때마다 스스로를 크게 할 수 있기 때문에(물론 메모리가 바닥나기 전까지 말이죠!) 코드는 더 단순할 뿐 아니라, 더 안전해졌습니다.</p>
<h2>반복(Iterating)</h2>
<p>for 반복문(for loop)은 배열이나 리스트의 요소(element)들에 따라 반복 실행되지만, 파이썬관느 문법이 약간 다릅니다. 예를 들어:</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token comment">// find the maximum point of a hailstone sequence stored in list</span>
<span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>리스트 뿐만 아니라 배열도 똑같이 반복(iterate)시킬 수 있습니다. 같은 코드에 리스트 대신 배열을 넣어도 잘 동작합니다.</p>
<p><code class="language-text">Math.max()</code>는 Java API에 포함되어있는 편리한 함수 입니다. <code class="language-text">Math</code>클래스는 이러한 편리한 함수들이 가득합니다 - "java 8 Math"를 웹에서 검색해 문서를 찾아보세요.</p>
<h2>메소드(Methods)</h2>
<p>보통 자바에서 구문들은 메소드의 안에 있어야 하고, 메소드들은 클래스의 안에 있어야 하기 때문에 우리의 우박 프로그램을 가장 간단하게 적으면 아래와 같습니다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hailstone</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
     * COmpute a hailstone sequence.
     * @param n Starting number for sequence. Assumes n > 0.
     * @return hailstone sequence starting with n and ending with 1.
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">hailstoneSequence</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">List</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                n <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>새로운 점 몇 가지를 설명해드리죠.</p>
<p><code class="language-text">public</code>은 프로그램 안의 어떤 코드던지, 그 클래스 혹은 메소드를 참조 할 수 있음을 의미합니다. <code class="language-text">private</code>과 같은 다른 접근 수정자(access modifiers)는 프로그램 내에서 조금 더 안전성을 확보하고, 불변성 타입(immutable types)의 불변성(immutability)를 보장하기 위해 사용됩니다.</p>
<p><code class="language-text">static</code>은 메소드 스스로가 인수를 받아 낼 수 없다는 것을 의미합니다. (which in Java is implicit anyway, you won't ever see it as a method parameter) 객체가 앞에 오는 <code class="language-text">List</code>의 <code class="language-text">add()</code>나 <code class="language-text">String</code> 의 <code class="language-text">length()</code>와는 반대로, 정적 메소드(Static methods)는 객체에서 호출 될 수 없습니다. 대신, 정적 메소드를 호출하는 올바른 방법은 객체를 참조하는 것이 아닌 아래와 같이 클래스의 이름을 이용하는 것 입니다.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token class-name">Hailstone</span><span class="token punctuation">.</span><span class="token function">hailstoneSequence</span><span class="token punctuation">(</span><span class="token number">83</span><span class="token punctuation">)</span></code></pre></div>
<p>메소드의 윗부분에는 꼭 주석을 남기도록 합시다. 매우 중요합니다. 이 주석은 메소드의 사양(specification)이며, 연산의 입력과 출력을 설명합니다. 이 사양은 간결하고 명확하고 정확해야 합니다. 이 주석은 메소드의 타입만으로는 명확하지 않은 정보들을 제공합니다. 주석 바로 아래에 <code class="language-text">int n</code>선언이 <code class="language-text">n</code>이 정수라는 것을 알려주기 때문에 주석에 적진 않습니다. 대신 <code class="language-text">n</code>이 반드시 양수이어야 한다는 사실은 타입 선언에서는 알 수 없지만 메소드를 호출할 때 매우 중요한 정보입니다.</p>
<p>좋은 사양을 적는 방법에 대해서는 앞으로 몇몇 강의들에서 더 설명하겠지만, 일단 우리는 바로 그것을 읽고 쓰도록 해야합니다.</p>
<h2>값 변경(Mutating Values) vs. 변수 재할당(reassigning Variables)</h2>
<p>다름 리딩에서 변수를 변경하는 것과 값을 바꾸는 것의 구별을 시각화 할 수 있는 방법인 스냅샷 다이어그램(snpashot diagrams)을 소개하겠습니다. 변수에 값을 할당할 떄, 우리는 변수의 화살표가 가리키는 곳의 값을 변경하는 것입니다. 다른 값을 가리키도록 할 수도 있죠.</p>
<p>배열이나 리스트와 같이 값을 변경 할 수 있는 컨텐츠(contents)들에 할당을 할 때, 우리는 그 값 안에 참조(references)를 변경하는 것입니다. When you assing to the contents of a mutable value - such as an array or list - you're changing references inside that value</p>
<p>변화는 필요악입니다. 좋은 프로그래머는 변화하는 것들을 피합니다. 왜냐면 그것들은 예기치 않게 변할 수 있기 때문이죠.</p>
<p>불변성, 즉 변화에 대한 내성은 이번 코스의 핵심 디자인 원리(design principle)입니다. 불변성 타입(immutable types)은 한 번 생성된 후에는 그 값을 절대 변경 할 수 없는 타입입니다. (최소한 밖에서 보이는 방식으론 불가합니다. 불변성에 대해서는 추후의 강의에서 더 이야기 하도록 하겠습니다.) 지금껏 우리가 이야기해온 타입들 중 어느 것이 불변성 타입이고 그 반대인가요?</p>
<p>자바는 또한 값을 한 번 할당하면 변경할 수 없는 불변성 레퍼런스(immuatble references)를 제공합니다. 참조(reference)를 불변하게 하고 싶다면, <code class="language-text">final</code>키워드와 함꼐 선언하세요.</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre></div>
<p>만약 final-변수가 단 한번만 할당되지 않는다면, 자바 컴파일러는 컴파일 오류를 발생시킬 것입니다. 따라서 final은 변하지 않는 참조 값에 대한 정적 검사를 제공해 줍니다.</p>
<p>메소드의 인수들과 지역(local) 변수를 가능한한 많이 final로 선언 하는 것이 좋습니다. 변수의 타입처럼, 이러한 선언은 프로그램의 독자에게 유용하며, 컴파일러에게 정적으로 검사를 받을 수 있는 중요한 문서입니다.</p>
<p>우리의 우박시퀀스 메소드에는 두 변수가 있습니다. 그들은 final로 선언해도 괜찮을까요? 아닐까요?</p>
<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">hailstoneSequence</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></div>
<h2>Assumption을 문서화 하기(Documenting Assumptions)</h2>
<p>변수의 타입을 적는 것은 그 변수에 대한 assumption을 문서화 하는 것입니다. 예를 들어, 이 변수는 항상 정수값만 참조한다 와 같이. 자바는 이러한 assumption을 컴파일 중에 실제로 검사하고, 우리의 프로그램내에 이러한 assumption을 어깃 곳이 없다는 것을 보장합니다.</p>
<p>변수를 final로 선언하는 것 또한 이 변수는 초기 할당 이후 절대 변하지 않는다는 선언을 문서화하는 것이죠. 자바는 그것도 정적으로 검사해줍니다.</p>
<p>우리는 (불행히도)자바가 정적으로 검사해주지 않는 assumption 또한 문서화했습니다. - n 이 항상 양수이어야 한다는 것 말이죠.</p>
<p>왜 우리의 assumption들을 적어두어야 하는 걸까요? 왜냐하면 프로그래밍은 이런 assumption들로 가득하며, 우리가 그것을 적어두지 않으면, 나중에 우리의 프로그램을 읽고 바꿔야 하는 사람들이 모르게 될 것이기 때문입니다. 그들은 추측을 하는 수 밖에 없게 됩니다.</p>
<p>프로그램은 마음속에서 다음과 같은 두가지 목표를 가지고 작성되어야 합니다.</p>
<ul>
<li>컴퓨터와 대화하는 것. 먼저 컴파일러에게 당신의 프로그램이 말이 된다는 것(옳은 문법과 옳은 타입)을 설득시키는 것이죠. 그 다음, 런타임에 올바른 결과를 얻어내도록 올바른 논리를 만드는 것이죠.</li>
<li>다른 사람과 대화하는 것. 다른 사람이 고치고, 개선하고, 적용할 수 있도록, 프로그램을 이해하기 쉽게 만드세요.</li>
</ul>
<h2>해킹(Hacking) vs. 엔지니어링(Engineering)</h2>
<p>이번 수업에서 우리는 해키(hacky)한 코드를 조금 적어보았습니다. 해킹은 종종 과도하게 낙관주의적인 경향이 있습니다. 예를 들어</p>
<ul>
<li>Bad : 아무것도 테스트 하기 전에, 많은 코드를 작성해버리기</li>
<li>Bad : 디테일한 내용을 코드에 적기 보단, 나중에 기억하겠거니 하며 머릿속에 두기</li>
<li>Bad : 버그가 없거나, 쉽게 찾고 고칠 수 있을거라고 추측하기</li>
</ul>
<p>하지만 소프트웨어 공학(Engineering)은 해킹이 아니죠. 엔지니어들은 비관적입니다. 예를 들어</p>
<ul>
<li>Good : 한 번에 조금만 적고, 테스트하며 진행하기. 추후의 강의에서, test-first-프로그래밍에 대해서도 이야기 하겠습니다.</li>
<li>Good : 코드안에 추측들(assumptions)을 문서화하기</li>
<li>Good : 당신의 코드를 멍청이들로부터 보호하기(특히 당신 자신!). 정적 검사는 그것을 도와줍니다.</li>
</ul>
<h2>6.005의 목표</h2>
<p>이 코스의 목표는 다음과 같은 소프트웨어를 만드는 법을 배우는 것입니다.</p>
<ul>
<li><strong>버그로부터 안전한</strong> : 정확성(지금 올바르게 동작)과 방어(력? defensiveness)(향후에 올바르게 동작) ?(향후에 동작을 수정)</li>
<li><strong>이해하기 쉬운</strong> : 향후에 프로그램을 이해하고 바꾸어야(버그를 고치고 새 기능을 추가) 하는 프로그래머들과 소통할 수 있도록. 그 미래의 프로래머는 몇달 혹은 몇 년 후의 당신 스스로일 수도 있습니다. 당신 스스로가 적은 내용을 얼마나 많이 까먹는지 알게 되면 놀랄 것입니다. 그리고 좋은 디자인을 가지는 것이 미래의 자신에게 얼마나 도움이 되는지도.</li>
<li><strong>변화에 준비된</strong> : 소프트웨어는 늘 변합니다. 어떤 디자인은 변화를 쉽게 만들어 주지만, 또 어떤 디자인은 많은 코드를 버리고 새로쓰게 만듭니다.</li>
</ul>
<h2>이 코스에서 자바를 사용하는 이유</h2>
<p>여러분은 6.01강의를 수강했기 때문에, 파이썬이 익숙 할 것입니다. 그럼 왜 이 강의에서는 파이썬을 사용하지 않고, 자바를 사용하는 것일까요?</p>
<p>첫번째 이유는 <strong>안정성(safety)</strong>입니다. 자바에는 정적 검사가 있습니다. (우선적으로 타입 검사이지만, 메소드가 선언한 대로 반환을 하는지 등 또한 검사합니다.) 이 강의에서 우리는 소프트웨어 엔지니어링을 배우며, 버그로부터 안전한 것은 그러한 접근 방식의 핵심 원칙입니다. Java dials safety up to 11, 므로, 좋은 소프트웨어 엔지니어링을 연습하기에 좋은 언어입니다. 파이썬과 같은 동적 언어로도 안전한 코드를 작성하는 것이 분명 가능하지만, 안전한 코드를 만들기 위해 무엇을 해야하는지 알기 위해서는 정적 검사 언어가 이해하기 쉽습니다.</p>
<p>또 다른 이유는 <strong>범용성(ubiquity)</strong>입니다. 자바는 연구, 교육, 산업에 널리 이용되는 언어입니다. 자바는 윈도우/맥/리눅스 이외에도 많은 플랫폼에서 동작합니다. 자바는 웹 프로그래밍(서버와 클라이언트 모두), 네이티브 안드로이드 프로그래밍에 사용됩니다. 다른 몇몇 언어들이 프로그래밍을 가르치기에는 더 좋지만(Scheme 과 ML정도가 떠오르네요) 안타깝게도 자바만큼 실제 세상에 널리 퍼져있진 않습니다. 여러분의 이력서(resume)에 적힌 자바는 시장가치가 있는 기술로 여겨질 것입니다. 하지만 오해하진 마세요. 여러분이 이 코스에서 정말로 얻게 될 것은 자바에만 한정된 것이 아닌, 여러분이 프로그래밍 하게 될 어떤 언어에도 적용시킬 수 있는 것들입니다. 안정성, 명확성, 추상화, 공학적 본능과 같은 이번 강의에서 배우게될 가장 중요한 교훈들은 언어의 유행들 속에서 살아남을 것입니다.</p>
<p>어떠한 경우에도, 좋은 프로그래머는 다국어자(multilingual)이어야 합니다. 프로그래밍 언어는 도구이며, 여러분은 각 일거리에 맞는 도구를 사용해야 합니다. 여러분은 MIT에 졸업하기도 전에 다른 프로그래밍 언어들을 또 사용하게 될 것 입니다. (JavaScript, C/C++, Scheme 또는 Ruby 또는 ML 또는 Haskell) 그래서 우린 바로 두번째 언어를 배우는 것입니다.</p>
<p>이러한 범용성의 결과, 자바는 수 많은 흥미롭고 유용한 라이브러리들(방대한 내장 라이브러리 뿐만 아니라 넷상에 있는 다른 라이브러리들 까지)과 훌륭한 무료 개발 도구(이클립스Eclipse와같은 IDE부터 에디터, 컴파일러, 테스트 프레임워크, 프로파일러, 코드 커버리지, 스타일 검사기)들을 가지고 있습니다. 파이썬조차 이런 자바의 풍성한 생태계에는 뒤쳐지고 있죠.</p>
<p>자바를 사용하는것이 후회되는 몇몇 이유도 있습니다. 자바는 말이 깁니다. 따라서 예시를 보드에 적기가 힘들죠. 또 오랜 시간동안 많은 기능들을 축적해서 너무 큽니다. 내부적으로 일관성이 없습니다. (<code class="language-text">final</code>키워드는 각 경우에 따라 다른 의미를 가지며, <code class="language-text">static</code>키워드는 정적 검사와는 아무런 연관도 없죠.) it's weighted with the baggage of older languages lik C/C++. 원시타입과 <code class="language-text">switch</code>문이 좋은 예시죠. 파이썬과 같은 인터프리터(interpreter)가 없어 작은 코드를 만져가며 배울 수 없죠.</p>
<p>그러나 전체적으로, 자바는 버그로부터 안전하고, 이해하기 쉽고, 변경할 준비가 된 코드를 작성하기에 합리적인 선택입니다. 그리고 그것이 우리의 목표이죠.</p>
<h2>요약(Summary)</h2>
<p>오늘 소개한 주된 개념은 <strong>정적 검사(static checking)</strong>입니다. 그리고 이 개념이 우리의 목표와 어떻게 연관 되었는지는 다음과 같습니다.</p>
<ul>
<li><strong>버그로부터 안전한(safe from bugs)</strong> : 정적 검사는 타입 오류와 기타 버그를 런타입 이전에 잡아주므로 안정성에 도움이 됩니다.</li>
<li><strong>이해하기 쉬운(Easy to understand)</strong> : 타입이 코드에 명확하게 적혀있으므로, 이해하는데 도움이 됩니다.</li>
<li><strong>변경할 준비가 된(Ready for change)</strong> : 정적 검사를 사용하면 동시에 변경해야하는 다른 위치를 식별하여 코드를 쉽게 변경할 수 있습니다. 예를 들어 변수의 이름이나 타입을 변경하면 컴파일러는 해당 변수가 사용되는 모든 위치에 오류를 즉시 표시하여 업데이트하도록 알려줍니다.</li>
</ul></div></div></div><span class="disqus-comment-count" data-disqus-identifier="/posts/reading-2-static-checking" data-disqus-url="hanool.github.com/posts/reading-2-static-checking">...</span><div id="disqus_thread"></div></main><footer style="margin-top:2rem">© <!-- -->2020<!-- -->, Built with<!-- --> <a href="https://www.gatsbyjs.com">Gatsby</a></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/reading-2-static-checking";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-468c4058c22b248959e4.js"],"app":["/app-6630ef88235aa306c41d.js"],"component---cache-caches-gatsby-plugin-offline-app-shell-js":["/component---cache-caches-gatsby-plugin-offline-app-shell-js-0097d26fbd474b34ff9b.js"],"component---src-pages-404-js":["/component---src-pages-404-js-9db65aa29e7deb9d7c95.js"],"component---src-pages-about-js":["/component---src-pages-about-js-e10ab16305924715af52.js"],"component---src-pages-index-js":["/component---src-pages-index-js-04237804bd1ad390d649.js"],"component---src-pages-posts-js":["/component---src-pages-posts-js-e62b50de45b9f4e2a214.js"],"component---src-templates-post-template-js":["/component---src-templates-post-template-js-fabb72bb863d7da60910.js"]};/*]]>*/</script><script src="/polyfill-468c4058c22b248959e4.js" nomodule=""></script><script src="/component---src-templates-post-template-js-fabb72bb863d7da60910.js" async=""></script><script src="/93a75765fdacf44a41c62e8a54345fad25392349-416bc51ce4ed34ec148a.js" async=""></script><script src="/styles-89fd2ae28bdf06750a71.js" async=""></script><script src="/app-6630ef88235aa306c41d.js" async=""></script><script src="/framework-9d194516e0be0e5de3bc.js" async=""></script><script src="/webpack-runtime-da31a781e9bbfb08e6c9.js" async=""></script></body></html>